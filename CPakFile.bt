struct File;
struct CPakFile;

struct AssetDirectoryEntry {
    FourCC type;
    GUID id;
    uint32 versionA;
    uint32 versionB;
    uint64 offset;
    uint64 decompressedSize;
    uint64 size;

    local uint64 pos <format=hex, hidden=true> = FTell();
    FSeek(offset);
    if (size == decompressedSize) {
        File data(false) <size=size>;
    } else {
        uint32 compressionMode;
        byte compressedData[size - 4];
    }
    FSeek(pos);
};

struct MetaEntry(uint64 start, CPakFile& pak) {
    GUID id;
    uint32 offset;

    // Find the FourCC for the asset ID
    // Assumes TOCC chunk 0 is ADIR
    // Currently disabled, very slow
    local FourCC type <hidden=true>;
    if (false) {
        local uint32 i <hidden=true>;
        for (i = 0; i < pak.chunk[0].count; i++) {
            if (pak.chunk[0].entry[i].id == id) {
                type = pak.chunk[0].entry[i].type;
                break;
            }
        }
    }

    local uint64 pos <format=hex, hidden=true> = FTell();
    FSeek(start + offset);
    uint32 size;
    Meta data(type, size);
    FSeek(pos);
};

struct StringEntry {
    uint32 type <read=FourCCInt>;
    GUID id;
    uint32 length;
    char name[length];
};

struct TOCChunk(CPakFile& pak)
{
    ChunkDescriptor chunk;
    local uint64 start <format=hex, hidden=true> = FTell();
    switch (chunk.id)
    {
        case "ADIR":
            uint32 count;
            AssetDirectoryEntry entry[count] <optimize=false, size=52>;
            break;
        case "META":
            uint32 count;
            MetaEntry entry(start, pak)[count] <optimize=false, size=20>;
            break;
        case "STRG":
            uint32 count;
            StringEntry entry[count] <optimize=false>;
            break;
    }
    FSeek(start + chunk.size);
};

struct CPakFile
{
    FormDescriptor toc;
    local uint64 start <format=hex, hidden=true> = FTell(); 
    while (FTell() < start + toc.size) {
        TOCChunk chunk(this);
    }
};