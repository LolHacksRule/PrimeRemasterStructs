#include "CAABox.bt"
#include "CEvalSystem.bt"
#include "CVector4i.bt"

struct SModelAnimatedUVData {
  CEvalSystem evalSystem;
  uint evalIdCount;
  CEvalId evalId[evalIdCount];
  uint vec4iCount;
  CVector4i vec4is[vec4iCount];
  uint unkCount;
  char unk[unkCount];
  uchar unk2;
};

struct DataSourceLoader {
  FourCC type;
  switch (type) {
  case "ANUV":
    SModelAnimatedUVData animatedUvs;
    break;
  }
};

struct CustomDataLoader {
  FourCC type;
};

struct ModelHeader {
  uint unk1;
  CAABox bounds;
  uint dataSourceCount;
  local int i;
  for (i = 0; i < dataSourceCount; ++i) {
    DataSourceLoader dataSource;
  }
  uchar unk2;
  if (unk2) {
    CustomDataLoader customData;
  }
};

struct MaterialTypeExtra {
   char type[4];
   char format[4];
   //version?
   byte unk;
   byte unk;
};

struct MaterialType;

typedef struct {
   char type[4];
   char format[4];
}MaterialType <read=MaterialTypeRead>;

struct STextureUsageInfo{
   uint flags;
   uint filter;
   uint wrapX;
   uint wrapY;
   uint wrapZ;
};

struct CMaterialTextureTokenData{
   GUID textureID;
   STextureUsageInfo usage;
};

struct MaterialData{
   char type[4];
   char format[4];
   switch (format)
   {
        case "TXTR":
            CMaterialTextureTokenData texture;
        break;
        case "COLR":
            float color[4];
        break;
        case "SCLR":
            float scalar;
        break;
        case "INT ":
            int int1;
        break;
        case "INT4":
            int int4[4];
        break;
        case "CPLX":
            uint unk;
            float color1[4];
            float color2[4];
            float color3[4];
            byte flags;
            GUID texture1ID;
            if (texture1ID != 0) CMaterialTextureTokenData texture1;
            GUID texture2ID;
            if (texture2ID != 0) CMaterialTextureTokenData texture2;
            GUID texture3ID;
            if (texture3ID != 0) CMaterialTextureTokenData texture3;
    
        break;
   }
};

struct CMaterialCache {
  CStringFixed name;
  GUID shaderID;
  GUID guid2; //unsure
  uint unk1;
  uint unk2;
  //material type list (can be 0)
  uint typeCount;
  uint types[typeCount];
  //material data types (with extra value)
  uint dataTypeExtraCount;
  MaterialTypeExtra dataTypes1[dataTypeExtraCount];
  //material data types
  uint dataCount;
  MaterialType dataTypes2[dataCount];
  //data parse
  MaterialData data[dataCount] <optimize=false>;
};

typedef struct CRenderMesh {
  ushort MaterialIndex;
  byte VertexBufferIndex;
  byte IndexBufferIndex;
  uint IndexStart;
  uint IndexCount;
  ushort field_C;
  ushort field_E; //0x4000
} CRenderMesh;

struct SMeshLoadInformation {
    uint meshCount;
    CRenderMesh meshes[meshCount];
};

typedef struct {
  ChunkDescriptor chunk;

  local uint pos<format = hex, hidden = true> = FTell();
  switch (chunk.id) {
  case "HEAD":
    ModelHeader header;
    break;
  case "MTRL":
    uint unk;
    uint numMaterials;
    CMaterialCache materials[1]<optimize = false>;
    break;
  case "MESH":
    SMeshLoadInformation loadInformation;
    break;
  }
  FSeek(pos + chunk.size);
} ModelChunk <name=(Str("%s chunk", chunk.id))>;

typedef struct(uint64 size) {
    local uint64 start <format=hex, hidden=true> = FTell();
    while (FTell() < start + size) {
        ModelChunk chunk;
    }
} ModelFile <name="Model chunks">;

string MaterialTypeRead(MaterialType &str)
{
    return str.type + str.format;
}