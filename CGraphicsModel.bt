#include "CAABox.bt"
#include "CEvalSystem.bt"
#include "CVector4i.bt"

struct SModelAnimatedUVData {
  CEvalSystem evalSystem;
  uint evalIdCount;
  CEvalId evalId[evalIdCount];
  uint vec4iCount;
  CVector4i vec4is[vec4iCount];
  uint unkCount;
  char unk[unkCount];
  uchar unk2;
};

struct DataSourceLoader {
  FourCC type;
  switch (type) {
  case "ANUV":
    SModelAnimatedUVData animatedUvs;
    break;
  }
};

struct CustomDataLoader {
  FourCC type;
};

struct ModelHeader {
  uint unk1;
  CAABox bounds;
  uint dataSourceCount;
  local int i;
  for (i = 0; i < dataSourceCount; ++i) {
    DataSourceLoader dataSource;
  }
  uchar unk2;
  if (unk2) {
    CustomDataLoader customData;
  }
};

typedef struct {
   char type[4];
   char format[4];
   byte flag1;
   byte flag2;
} MaterialRenderTypes <name=(Str("%s %s", type, format))>;

typedef struct {
   char type[4];
   char format[4];
} MaterialType <name=(Str("%s %s", type, format))>;

struct STextureUsageInfo{
   uint flags;
   uint filter;
   uint wrapX;
   uint wrapY;
   uint wrapZ;
};

typedef struct{
   GUID id;
   STextureUsageInfo usage;
} CMaterialTextureTokenData <name=(Str("%s", GUIDToString(this.id)))>;

typedef struct{
   char type[4];
   char format[4];
   switch (format)
   {
        case "TXTR":
            CMaterialTextureTokenData texture;
        break;
        case "COLR":
            float color[4];
        break;
        case "SCLR":
            float scalar;
        break;
        case "INT ":
            int int1;
        break;
        case "INT4":
            int int4[4];
        break;
        case "CPLX":
            uint unk;
            float color1[4];
            float color2[4];
            float color3[4];
            byte flags;
            GUID texture1ID;
            if (texture1ID != 0) CMaterialTextureTokenData texture1;
            GUID texture2ID;
            if (texture2ID != 0) CMaterialTextureTokenData texture2;
            GUID texture3ID;
            if (texture3ID != 0) CMaterialTextureTokenData texture3;
    
        break;
   }
} CMaterialData <read=CMaterialDataRead>;

string CMaterialDataRead(CMaterialData &mat)
{
	string s;
	
   switch (mat.format)
   {
        case "TXTR": SPrintf(s, "Texture: %s = %s", mat.type, GUIDToString(mat.texture.id)); break;
        case "COLR": SPrintf(s, "Color %s = %f %f %f %f", mat.type, mat.color[0], mat.color[1], mat.color[2], mat.color[3]); break;
        case "SCLR": SPrintf(s, "Scalar %s = %f", mat.type, mat.scalar); break;
        case "INT ": SPrintf(s, "Int %s = %f", mat.type, mat.int1); break;
        case "INT4": SPrintf(s, "Int4 %s = %u %u %u %u", mat.type, mat.int4[0], mat.int4[1], mat.int4[2], mat.int4[3]); break;
        case "CPLX": SPrintf(s, "Complex: %s", mat.type); break;
   }
	return s;
}

struct CMaterialCache {
  CStringFixed name;
  GUID shaderID;
  GUID guid2; //unsure
  uint unk1;
  uint unk2;
  //material type list (can be 0)
  uint typeCount;
  uint types[typeCount];
  //material data types (with extra value)
  uint renderTypeCount;
  MaterialRenderTypes renderTypes[renderTypeCount];
  //material data types
  uint dataCount;
  MaterialType dataTypes2[dataCount];
  //data parse
  CMaterialData data[dataCount] <optimize=false>;
};

typedef struct CRenderMesh {
  ushort MaterialIndex;
  byte VertexBufferIndex;
  byte IndexBufferIndex;
  uint IndexStart;
  uint IndexCount;
  ushort field_C;
  ushort field_E; //0x4000
} CRenderMesh;

struct SMeshLoadInformation {
    uint meshCount;
    CRenderMesh meshes[meshCount];
};

typedef struct {
  ChunkDescriptor chunk;

  local uint pos<format = hex, hidden = true> = FTell();
  switch (chunk.id) {
  case "HEAD":
    ModelHeader header;
    break;
  case "MTRL":
    uint unk;
    uint numMaterials;
    CMaterialCache materials[numMaterials]<optimize = false>;
    break;
  case "MESH":
    SMeshLoadInformation loadInformation;
    break;
  }
  FSeek(pos + chunk.size);
} ModelChunk <name=(Str("%s chunk", chunk.id))>;

typedef struct(uint64 size) {
    local uint64 start <format=hex, hidden=true> = FTell();
    while (FTell() < start + size) {
        ModelChunk chunk;
    }
} ModelFile <name="Model chunks">;