#include "CAABox.bt"
#include "CEvalSystem.bt"
#include "CVector4i.bt"

struct SModelAnimatedUVData {
  CEvalSystem evalSystem;
  uint evalIdCount;
  CEvalId evalId[evalIdCount];
  uint vec4iCount;
  CVector4i vec4is[vec4iCount];
  uint unkCount;
  char unk[unkCount];
  uchar unk2;
};

struct DataSourceLoader {
  FourCC type;
  switch (type) {
  case "ANUV":
    SModelAnimatedUVData animatedUvs;
    break;
  }
};

struct CustomDataLoader {
  FourCC type;
};

struct ModelHeader {
  if (isDKCTF == 1)
  {
    uint opaqueMeshes;
    uint onePassTransMeshes;
    uint TwoPassTransMeshes;
    uint oneBitMeshes;
    uint additiveMeshes;
  }
  else
  {
    uint unk1;
  }
  CAABox bounds;
  uint dataSourceCount;
  local int i;
  for (i = 0; i < dataSourceCount; ++i) {
    DataSourceLoader dataSource;
  }
  if (isDKCTF == 0)
  {
    uchar unk2;
    if (unk2) {
      CustomDataLoader customData;
    }
  }
};

typedef struct {
   char type[4];
   char format[4];
   byte flag1;
   byte flag2;
} MaterialRenderTypes <name=(Str("%s %s", type, format))>;

typedef struct {
   char type[4];
   char format[4];
} MaterialType <name=(Str("%s %s", type, format))>;

struct STextureUsageInfo{
   uint flags;
   uint filter;
   uint wrapX;
   uint wrapY;
   uint wrapZ;
};

typedef struct{
   GUID id;
   STextureUsageInfo usage;
} CMaterialTextureTokenData <name=(Str("%s", GUIDToString(this.id)))>;

typedef struct{
   char type[4];
   char format[4];
   switch (format)
   {
        case "TXTR":
            CMaterialTextureTokenData texture;
        break;
        case "COLR":
            float color[4];
        break;
        case "SCLR":
            float scalar;
        break;
        case "INT ":
            int int1;
        break;
        case "INT4":
            int int4[4];
        break;
        case "CPLX":
            uint unk;
            float color1[4];
            float color2[4];
            float color3[4];
            byte flags;
            GUID texture1ID;
            if (texture1ID != 0) CMaterialTextureTokenData texture1;
            GUID texture2ID;
            if (texture2ID != 0) CMaterialTextureTokenData texture2;
            GUID texture3ID;
            if (texture3ID != 0) CMaterialTextureTokenData texture3;
    
        break;
   }
} CMaterialData <read=CMaterialDataRead>;

/* MaterialID Mappings:
    MFTR  = 0,
    MFMT  = 1,
    TXTR  = 1,
    CBUF  = 1,    
    ZBUF  = 2,
    COLR  = 2,
    MFSR  = 2,
    SCLR  = 3,
    GBUF  = 3,
    MFSK  = 3,
    INT1  = 4,
    GFLG  = 4,
    MFVC  = 4,
    CPLX  = 5,
    TCPO  = 5,
    MF1B  = 5,
    DIFT  = 6,
    INT4  = 6,
    MFAV  = 6,
    MAT4  = 7,
    ICAN  = 7,
    MFIN  = 7,
    SINC  = 8,
    MFCA  = 8,
    NMAP  = 9,
    MFIN  = 9,
    MNMP  = 10,
    MTSM  = 10,
    REFL  = 11,
    MFRL  = 11,
    REFS  = 12,
    MFOE  = 12,
    REFV  = 13,
    MFOT  = 13,
    SPCT  = 14,
    MFCI  = 14,
    LIDB  = 15,
    MFOI  = 15,
    LIBS  = 16,
    MFVA  = 16,
    FOGR  = 17,
    MFSU  = 17,
    INDI  = 18,
    MFBP  = 18,
    OTMP  = 19,
    MFBL  = 19,
    CGMP  = 20,
    MFLB  = 20,
    OGMP  = 21,
    MF1E  = 21,
    VAND  = 22,
    MFC0  = 22,
    MFC1  = 23,
    BLAT  = 23,
    BCLR  = 24,
    MFC2  = 24,
    MFC3  = 25,
    METL  = 25,
    MFC4  = 26,
    TCH0  = 26,
    TCH1  = 27,
    TCH2  = 28,
    TCH3  = 29,
    TCH4  = 30,
    TCH5  = 31,
    DIFC  = 32,
    SHRC  = 33,
    SPCC  = 34,
    ICNC  = 35,
    ICMC  = 36,
    ODAT  = 37,
    MDCI  = 38,
    MODI  = 39,
    LODC  = 40,
    LODP  = 41,
    VANP  = 42,
    BLAL  = 43,
    BLCM  = 44,
    INDP  = 45,
    PVLO  = 46,
    PSXT  = 47,
    PTAI  = 48,
    PCMD  = 49,
    BSAO  = 50,
    CCH0  = 51,
    CCH1  = 52,
    CCH2  = 53,
    CCH3  = 54,
    CCH4  = 55,
    CCH5  = 56,
    CCH6  = 57,
    BKLT  = 58,
    BKLB  = 59,
    BKLA  = 60,
    BKGL  = 61,
    DYIN  = 62,
    CLP0  = 63,
    HOTP  = 64,
    SHID  = 65,
    GBFF  = 66,
    PMOD  = 67,
    PFLG  = 68,
    BLPI  = 69,
    ICH0  = 70,
    ICH1  = 71,
    ICH2  = 72,
    AUVI  = 73,
    ECH0  = 74,
    OPCS  = 75,
    SPCP  = 76,
    INDS  = 77,
    BLSM  = 78,
    LITS  = 79,
    MDOE  = 80,
    VANF  = 81,
    OTHS  = 82,
    PZSO  = 83,
    RCH0  = 84,
    RCH1  = 85,
    RCH2  = 86,
    PXFM  = 87,
    MCH0  = 88,
    SHDD  = 89,
    BCLR  = 89,
    SKIN  = 90,
    MTLL  = 90,
    NRML  = 91,
    DIMD  = 94,
   "TIL " = 95,
    ALLD  = 96,
    DLLD  = 97,
    DLLC  = 98,
    AUXF  = 99,
    WIND  = 100,
    WATR  = 101,
    DFXS  = 102,
    DXFN  = 103,
    MCDD  = 104,
    CAUS  = 105,
    PLDB  = 106,
    BLPT  = 107,
    FOGS  = 108,
    VOLF  = 109,
    VFXB  = 110,
    VFXD  = 111,
    REFP  = 112,
    RAIN  = 113,
    XCH0  = 114,
    XCH1  = 115,
*/

string CMaterialDataRead(CMaterialData &mat)
{
	string s;
	
   switch (mat.format)
   {
        case "TXTR": SPrintf(s, "Texture: %s = %s", mat.type, GUIDToString(mat.texture.id)); break;
        case "COLR": SPrintf(s, "Color %s = %f %f %f %f", mat.type, mat.color[0], mat.color[1], mat.color[2], mat.color[3]); break;
        case "SCLR": SPrintf(s, "Scalar %s = %f", mat.type, mat.scalar); break;
        case "INT ": SPrintf(s, "Int %s = %f", mat.type, mat.int1); break;
        case "INT4": SPrintf(s, "Int4 %s = %u %u %u %u", mat.type, mat.int4[0], mat.int4[1], mat.int4[2], mat.int4[3]); break;
        case "CPLX": SPrintf(s, "Complex: %s", mat.type); break;
   }
	return s;
}

typedef struct {
  CStringFixed name;
  GUID shaderID;
  if (isDKCTF == 1)
  {
    local uint typeCount <hidden=true> = 1; //Hack it to 1
  }
  else
  {
    GUID guid2; //unsure
    uint unk1;
    uint unk2;
    //material type list (can be 0)
    uint typeCount;
  }
  uint types[typeCount];
  if (isDKCTF == 1)
  {
    uint flags;
  }
  else
  {
    //material data types (with extra value)
    uint renderTypeCount;
    MaterialRenderTypes renderTypes[renderTypeCount];
  }
  //material data types
  uint dataCount;
  MaterialType dataTypes2[dataCount];
  //data parse
  CMaterialData data[dataCount] <optimize=false>;
} CMaterialCache <name=(Str("%s %s", this.name.text, GUIDToString(this.shaderID)))>;

typedef struct {
  ushort MaterialIndex;
  byte VertexBufferIndex;
  byte IndexBufferIndex;
  uint IndexStart;
  uint IndexCount;
  ushort field_C;
  ushort field_E; //0x4000
} CRenderMesh;

struct SMeshLoadInformation {
    uint meshCount;
    CRenderMesh meshes[meshCount];
};

typedef struct {
  ChunkDescriptor chunk;

  local uint pos<format = hex, hidden = true> = FTell();
  switch (chunk.id) {
  case "HEAD":
    ModelHeader header;
    break;
  case "MTRL":
    if (isDKCTF == 0)
    {
        uint unk;
    }
    uint numMaterials;
    CMaterialCache materials[numMaterials]<optimize = false>;
    break;
  case "MESH":
    SMeshLoadInformation loadInformation;
    break;
  }
  FSeek(pos + chunk.size);
} ModelChunk <name=(Str("%s chunk", chunk.id))>;

typedef struct(uint64 size) {
    local uint64 start <format=hex, hidden=true> = FTell();
    while (FTell() < start + size) {
        ModelChunk chunk;
    }
} ModelFile <name="Model chunks">;