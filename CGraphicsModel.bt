#ifndef _CGRAPHICSMODEL
#define _CGRAPHICSMODEL
#include "CAABox.bt"
#include "CEvalSystem.bt"
#include "CVector4i.bt"
#include "CRenderOctree.bt"
#include "NGraphicsMaterial.bt"

struct SModelAnimatedUVData {
  CEvalSystem evalSystem;
  uint evalIdCount;
  CEvalId evalId[evalIdCount];
  uint vec4iCount;
  CVector4i vec4is[vec4iCount];
  uint unkCount;
  char unk[unkCount];
  if (!isDKCTF)
  {
    uchar unk2;
  }
};

struct DataSourceLoader {
  if (ReadByte() == 0)
  {
    uint32 tmpFormatI32;
    switch (tmpFormatI32)
    {
      case 0:
        local FourCC type = "ANUV";
    }
  }
  else
  {
    FourCC type;
  }
  switch (type) {
  case "ANUV":
    SModelAnimatedUVData animatedUvs;
    break;
  }
};

struct CustomDataLoader {
  FourCC type;
};

struct ModelHeader {
  if (isDKCTF == 1)
  {
    uint opaqueMeshes;
    uint onePassTransMeshes;
    uint TwoPassTransMeshes;
    uint oneBitMeshes;
    uint additiveMeshes;
  }
  else
  {
    uint unk1;
  }
  CAABox bounds;
  uint dataSourceCount;
  local int i;
  for (i = 0; i < dataSourceCount; ++i) {
    DataSourceLoader dataSource;
  }
  if (isDKCTF == 0)
  {
    uchar unk2;
    if (unk2) {
      CustomDataLoader customData;
    }
  }
};

typedef struct {
    char type[4];
    char format[4];
    byte flag1;
    byte flag2;
} MaterialRenderTypes <name=(Str("%s %s", type, format))>;

typedef struct {
    FourCC id <read=ReadMaterialDataId>;
    FourCC type <read=ReadMaterialDataType>;
} MaterialType <read=(Str("%s %s", id, type))>;

struct STextureUsageInfo {
    uint flags;
    uint filter;
    uint wrapX;
    uint wrapY;
    uint wrapZ;
};

struct SSkinnedModelHeader {
    uint unk;
    if (!isDKCTF)
    {
        uint unk;
        uint unk;
        uint unk;
        uint uintsCount;
        uint uints[uintsCount];
        uint dataCount;
        uint data[dataCount];
    }
};

struct SWorldModelHeader {
    uchar unk;
};

enum <uint32> ECachedGraphicsTransform
{
    XF_MODEL_TO_WORLD_MTX = 0, // uc_modelToWorldMatrix
    XF_WORLD_TO_MODEL_MTX = 1, // uc_worldToModelMatrix
    XF_WORLD_TO_VIEW_MTX = 2, // uc_worldToViewMatrix
    XF_PROJECTION_MTX = 3, // uc_projectionMatrix
    XF_MODEL_VIEW_MTX = 4, // uc_modelViewMatrix
    XF_MODEL_VIEW_PROJECTION_MTX = 5, // uc_modelViewProjectionMatrix
    XF_PROJECTION_INVERSE_MTX = 6, // uc_projectionInverseMatrix
    XF_NORMAL_MTX = 7, // uc_normalMatrix
    XF_CUSTOM_MTX_0 = 8, // uc_customMatrix0
};

enum <uint32> EVertexComponent
{
    VTX_POSITION = 0, // in_position
    VTX_NORMAL = 1, // in_normal
    VTX_TANGENT0 = 2, // in_tangent[0]
    VTX_TANGENT1 = 3, // in_tangent[1]
    VTX_TANGENT2 = 4, // in_tangent[2]
    VTX_TEXCOORD0 = 5, // in_texCoord[0]
    VTX_TEXCOORD1 = 6, // in_texCoord[1]
    VTX_TEXCOORD2 = 7, // in_texCoord[2]
    VTX_TEXCOORD3 = 8, // in_texCoord[3]
    VTX_COLOR = 9, // in_color
    VTX_BONE_INDICES = 10, // in_boneIndices
    VTX_BONE_WEIGHTS = 11, // in_boneWeights
    VTX_BAKED_LIGHTING_COORD = 12, // in_bakedLightingCoord
    VTX_BAKED_LIGHTING_TANGENT = 13, // in_bakedLightingTangent
    VTX_VERT_INSTANCE_PARAMS = 14, // in_vertInstanceParams
    VTX_VERT_INSTANCE_COLOR = 15, // in_vertInstanceColor
    VTX_VERT_TRANSFORM0 = 16, // in_vertTransform[0]
    VTX_VERT_TRANSFORM1 = 17, // in_vertTransform[1]
    VTX_VERT_TRANSFORM2 = 18, // in_vertTransform[2]
    VTX_CURRENT_POSITION = 19, // in_currentPosition
    VTX_VERT_INSTANCE_OPACITY_PARAMS = 20, // in_vertInstanceOpacityParams
    VTX_VERT_INSTANCE_COLOR_INDEXING_PARAMS = 21, // in_vertInstanceColorIndexingParams
    VTX_VERT_INSTANCE_OPACITY_INDEXING_PARAMS = 22, // in_vertInstanceOpacityIndexingParams
    VTX_VERT_INSTANCE_PAINT_PARAMS = 23, // in_vertInstancePaintParams
    VTX_BAKED_LIGHTING_LOOKUP = 24, // in_bakedLightingLookup
    VTX_MATERIAL_CHOICE0 = 25, // in_materialChoice[0]
    VTX_MATERIAL_CHOICE1 = 26, // in_materialChoice[1]
    VTX_MATERIAL_CHOICE2 = 27, // in_materialChoice[2]
    VTX_MATERIAL_CHOICE3 = 28, // in_materialChoice[3]
};

enum <uint32> EMaterialDataType
{
    DATA_TYPE_NONE = 0,
    DATA_TYPE_TEXTURE = 1, // TXTR
    DATA_TYPE_COLOR = 2, // COLR
    DATA_TYPE_SCALAR = 3, // SCLR
    DATA_TYPE_INT1 = 4, // INT1
    DATA_TYPE_COMPLEX = 5, // CPLX
    DATA_TYPE_INT4 = 6, // INT4
    DATA_TYPE_MAT4 = 7, // MAT4
};

EMaterialDataType MapMaterialDataType(FourCC value)
{
    switch (value) {
    case "TXTR":
        return DATA_TYPE_TEXTURE;
    case "COLR":
        return DATA_TYPE_COLOR;
    case "SCLR":
        return DATA_TYPE_SCALAR;
    case "INT1":
        return DATA_TYPE_INT1;
    case "CPLX":
        return DATA_TYPE_COMPLEX;
    case "INT4":
        return DATA_TYPE_INT4;
    case "MAT4":
        return DATA_TYPE_MAT4;
    default:
        return DATA_TYPE_NONE;
    }
}

string ReadMaterialDataType(FourCC value)
{
    EMaterialDataType type = MapMaterialDataType(value);
    return EnumToString(type);
}

typedef struct
{
    GUID id;
    if (id != GUIDZero || isDKCTF) { STextureUsageInfo usage; }
} CMaterialTextureTokenData <optimize=false>;

struct CLayeredTextureBaseData
{
    uint unk;
    float color1[4];
    float color2[4];
    float color3[4];
    byte flags;
};

struct CLayeredTextureData
{
    CLayeredTextureBaseData base;
    CMaterialTextureTokenData textures[3];
};

typedef struct {
    FourCC id <read=ReadMaterialDataId>;
    FourCC type <read=ReadMaterialDataType>;

    switch (MapMaterialDataType(type)) {
    case DATA_TYPE_TEXTURE:
        CMaterialTextureTokenData texture;
        break;
    case DATA_TYPE_COLOR:
        float color[4]; // CColor4f
        break;
    case DATA_TYPE_SCALAR:
        float scalar;
        break;
    case DATA_TYPE_INT1:
        int int1;
        break;
    case DATA_TYPE_INT4:
        int int4[4]; // CVector4i
        break;
    case DATA_TYPE_MAT4:
        float mtx[16]; // CMatrix4f
        break;
    case DATA_TYPE_COMPLEX:
        local EMaterialDataId dataId <hidden=true> = MapMaterialDataId(id);
        if (IsTextureLayeredMaterialDataId(dataId)) {
            CLayeredTextureData data;
        } else if (IsTextureMaterialDataId(dataId)) {
            // TODO
        }
        break;
    }
} CMaterialData <read=CMaterialDataRead>;

string CMaterialDataRead(CMaterialData &mat) {
    switch (MapMaterialDataType(mat.type)) {
    case DATA_TYPE_TEXTURE:
        return Str("Texture %s = %s", mat.id, GUIDToString(mat.texture.id));
    case DATA_TYPE_COLOR:
        return Str("Color %s = %f %f %f %f", mat.id, mat.color[0], mat.color[1], mat.color[2], mat.color[3]);
    case DATA_TYPE_SCALAR:
        return Str("Scalar %s = %f", mat.id, mat.scalar);
    case DATA_TYPE_INT1:
        return Str("Int %s = %f", mat.id, mat.int1);
    case DATA_TYPE_INT4:
        return Str("Int4 %s = %u %u %u %u", mat.id, mat.int4[0], mat.int4[1], mat.int4[2], mat.int4[3]);
    case DATA_TYPE_COMPLEX:
        return Str("Complex %s", mat.id);
    }
}

typedef struct {
  CStringFixed name;
  GUID shaderID;
  if (isDKCTF == 1)
  {
    local uint typeCount <hidden=true> = 1; //Hack it to 1
  }
  else
  {
    GUID guid2; //unsure
    uint unk1;
    uint unk2;
    //material type list (can be 0)
    uint typeCount;
  }
  struct { FourCC type; } types[typeCount];
  if (isDKCTF == 1)
  {
    uint flags;
  }
  else
  {
    //material data types (with extra value)
    uint renderTypeCount;
    MaterialRenderTypes renderTypes[renderTypeCount];
  }
  //material data types
  uint dataCount;
  MaterialType dataTypes2[dataCount];
  //data parse
  CMaterialData data[dataCount] <optimize=false>;
} CMaterialCache <name=(Str("%s %s", this.name.text, GUIDToString(this.shaderID)))>;

typedef struct {
  if (isDKCTF)
  {
    uint32 PrimitiveMode;
  }
  ushort MaterialIndex;
  byte VertexBufferIndex;
  byte IndexBufferIndex;
  uint IndexStart;
  uint IndexCount;
  ushort field_C;
  if (isDKCTF)
  {
     byte unk;
  }
  ushort field_E; //0x4000
} CRenderMesh;

struct SMeshLoadInformation {
    uint meshCount;
    CRenderMesh meshes[meshCount]<optimize=false>;
};

enum <uint32> EVertexDataFormat {
    FMT_R8_UNORM = 0,
    FMT_R8_UINT = 1,
    FMT_R8_SNORM = 2,
    FMT_R8_SINT = 3,
    FMT_R16_UNORM = 4,
    FMT_R16_UINT = 5,
    FMT_R16_SNORM = 6,
    FMT_R16_SINT = 7,
    FMT_R16_FLOAT = 8,
    FMT_RG8_UNORM = 9,
    FMT_RG8_UINT = 10,
    FMT_RG8_SNORM = 11,
    FMT_RG8_SINT = 12,
    FMT_R32_UINT = 13,
    FMT_R32_SINT = 14,
    FMT_R32_FLOAT = 15,
    FMT_RG16_UNORM = 16,
    FMT_RG16_UINT = 17,
    FMT_RG16_SNORM = 18,
    FMT_RG16_SINT = 19,
    FMT_RG16_FLOAT = 20,
    FMT_RGBA8_UNORM = 21,
    FMT_RGBA8_UINT = 22,
    FMT_RGBA8_SNORM = 23,
    FMT_RGBA8_SINT = 24,
    FMT_RGB10A2_UNORM = 25,
    FMT_RGB10A2_UINT = 26,
    FMT_RG32_UINT = 27,
    FMT_RG32_SINT = 28,
    FMT_RG32_FLOAT = 29,
    FMT_RGBA16_UNORM = 30,
    FMT_RGBA16_UINT = 31,
    FMT_RGBA16_SNORM = 32,
    FMT_RGBA16_SINT = 33,
    FMT_RGBA16_FLOAT = 34,
    FMT_RGB32_UINT = 35,
    FMT_RGB32_SINT = 36,
    FMT_RGB32_FLOAT = 37,
    FMT_RGBA32_UINT = 38,
    FMT_RGBA32_SINT = 39,
    FMT_RGBA32_FLOAT = 40,
};

struct SVertexDataComponent {
    uint32 bufferIndex;
    uint32 offset;
    uint32 stride;
    EVertexDataFormat format;
    EVertexComponent component;
};

struct SVertexBufferInfo {
    uint32 vertexCount;
    uint32 numAttributes;
    SVertexDataComponent component[numAttributes];
    if (!isDKCTF)
    {
        byte unk;
    }
};

struct CGraphicsVertexBufferToken {
    uint32 count;
    SVertexBufferInfo info[count] <optimize=false>;
};

enum <uint32> EBufferType {
    INDEX_U8 = 0, // ?
    INDEX_U16 = 1,
    INDEX_U32 = 2,
};

struct CGraphicsIndexBufferToken {
    uint32 count;
    EBufferType type[count];
};

typedef struct {
  ChunkDescriptor chunk;

  local uint pos<format = hex, hidden = true> = FTell();
  switch (chunk.id) {
  case "WDHD":
    SWorldModelHeader worldHeader;
    CRenderOctree renderOctree;
    uint aaboxCount;
    CAABox aaboxes[aaboxCount];
    uint floatCount;
    if (!isDKCTF)
    {
        float floats[floatCount];
        ushort unk;
        uint shortCount;
        ushort shorts[shortCount];
    }
    break;
  case "HEAD":
    ModelHeader header;
    break;
  case "SKHD":
    SSkinnedModelHeader skinnedModelHeader;
    break;
  case "MTRL":
    if (isDKCTF == 0)
    {
        uint unk;
    }
    uint numMaterials;
    CMaterialCache materials[numMaterials]<optimize = false>;
    break;
  case "MESH":
    SMeshLoadInformation loadInformation;
    break;
    case "VBUF":
        CGraphicsVertexBufferToken data;
        break;
    case "IBUF":
        CGraphicsIndexBufferToken data;
        break;
  }
  FSeek(pos + chunk.size);
} ModelChunk <name=(Str("%s chunk", chunk.id))>;

typedef struct(uint64 size) {
    local uint64 start <format=hex, hidden=true> = FTell();
    while (FTell() < start + size) {
        ModelChunk chunk;
    }
} ModelFile <name="Model chunks">;

// NModelFormat::SReadBufferInfo
struct SModelReadBufferInfo
{
    uint32 size <format=hex>;
    uint32 offset <format=hex>;
};

// NModelFormat::SBufferInfo
struct SModelBufferInfo
{
    uint32 index; // SModelReadBufferInfo index
    uint32 offset <format=hex>;
    uint32 size <format=hex>;
    uint32 destSize <format=hex>;
};

// NModelFormat::SMetaData
struct SModelMetaData(uint64 fileStart)
{
    uint32 unk;
    uint32 gpuOffset <format=hex>;
    uint32 readInfoCount;
    SModelReadBufferInfo readInfo[readInfoCount];
    uint32 vtxInfoCount;
    SModelBufferInfo vtxBufferInfo[vtxInfoCount];
    uint32 idxInfoCount;
    SModelBufferInfo idxBufferInfo[idxInfoCount];
};

#endif// _CGRAPHICSMODEL
