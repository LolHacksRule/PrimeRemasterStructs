#ifndef _CGAMEAREARESOURCE
#define _CGAMEAREARESOURCE

#include "CDataEnumObject.bt"

struct ProductionWorkStages {
  ushort count;
  local int i<hidden = true>;
  for (i = 0; i < count; ++i) {
    struct {
      uint id<format = hex>;
      ushort size;
      switch (id) {
      case 0x8333A604:
        CDataEnumValue val;
        break;
      case 0xB9187C94:
        CDataEnumValue val;
        break;
      case 0xEC5D9069:
        CDataEnumValue val;
        break;
      case 0x113F9CE1:
        uint productionStage;
        break;
      case 0x5CA42B9D:
        CDataEnumValue val;
        break;
      case 0x7B68B3A0:
        CDataEnumValue val;
        break;
      }
    } Property;
  }
};

struct GameAreaHeader {
  if (isDKCTF)
  {
    uint16 unk;
  }
  else
  {
    GUID id_a;
    ushort unk1;
    ushort unk2;
    bool unk3;
    GUID id_b;
    GUID id_c;
    GUID id_d;
    GUID id_e;
    GUID id_f;
    ProductionWorkStages workStages;
  }
};

struct ScriptPerformanceGroupResourceData {
  CStringFixed name;
  GUID unk2;
  uchar unk3;
  ushort count;
  if (count) {
    struct {
        GUID guid;
    } guids[count];
  }
};

struct PerformanceGroups {
  ushort dataCount;
  ScriptPerformanceGroupResourceData data[dataCount] <optimize = false>;
};

struct GeneratedObjectMap {
  ushort guidCount;
  if (guidCount) {
    struct {
      GUID guid1;
      GUID guid2;
    } guids[guidCount];
  }
};

struct Dock {
  GUID a;
  GUID b;
  GUID c;
  GUID d;
  ushort roomTypeA;
  ushort roomTypeB;
};

struct Docks {
  ushort dockCount;
  if (dockCount) {
    Dock docks[dockCount];
  }
};

struct SAtlasLookup {
  uint unkA;
  uint unkB;
  uint unkC;
  uint unkD;
};

struct BakedLightning {
  uint flags;
  if (flags & 1) {
    GUID guid1;
    uint guidCount;
    if (guidCount) {
      struct {
        GUID guid;
      } guids[guidCount];
    }
    uint lookupCount;
    if (lookupCount) {
      SAtlasLookup lookups[lookupCount];
    }
  }

  if ((flags >> 1) & 1) {
    GUID guid2;
  }
};

struct LoadUnitHeader {
  CStringFixed name;
  GUID id;
  if (isDKCTF)
  {
    uint16 unk;
  }
  else
  {
    GUID id2;
    ushort unk2;
    uint unk3;
    if (unk3)
      char unkData2[unk3];
      uint unk4;
    if (unk4)
      char unkData3[unk4];
  }
};

struct LoadUnitResources {
  uint guidCount;
  if (guidCount) {
    struct {
      GUID guids;
    } resIds[guidCount];
  }
};

struct LoadUnitLayers {
  uint guidCount2;
  if (guidCount2) {
    struct {
      GUID guids;
    } resIds2[guidCount2];
  }
};

struct StringPool {
    uint unk1;
    uint unk2;
    uint poolLen;
    if (poolLen) {
        char data[poolLen];
    }
};

struct STRP {
  uint unk1;
  uint numStrings1;
  if (numStrings1) {
    struct {
        uint strLen;
        char str[strLen];
    } strings1;
  }
  StringPool pool;
};

struct ScriptDataHeader {
    uint32 propertiesCount;
    uint32 instanceDataCount;
    uint32 dataLen;
    char data[dataLen * 0x18];
};

struct Component {
    uint32 componentTypeHash;
    GUID componentGUID;
    CStringFixed componentNmae;
    uint16 connectionCount;
    if (connectionCount) {
      struct {
          GUID connection1;
          GUID connection2;
          GUID componentID;
          uint16 unk;
          bool unk2;
          bool unk3;
      } connections;
    }
    uint16 scriptLinkCount;
    if (scriptLinkCount) {
      struct {
          GUID linkID;
          GUID componentID;
          bool unk;
      } connections;
    }
};

struct LayerHeader {
  CStringFixed name;
  GUID id;
  if (isDKCTF)
  {
    uint16 unk;
    ushort count;
    struct {
        GUID guid;
    } guids[count+1];
    bool unk2;
  }
  else
  {
    int unk;
  }
};

struct RoomChunk;
typedef struct {
    if (ReadString(FTell(), 4) == "RFRM") {
        FormDescriptor desc;
    } else {
        ChunkDescriptor desc;
    }
    local uint64 start <hidden = true> = FTell();
    switch (desc.id) {
    case "HEAD":
    case "LUNT":
    case "SDTA":
    case "LYRS":
    case "LAYR":
    case "GSRP":
    case "SRIP":
        while (FTell() < start + desc.size) {
          RoomChunk chunk;
        }
        break;
    case "RMHD":
        GameAreaHeader data;
        break;
    case "PGRP":
        PerformanceGroups data;
        break;
    case "LGEN":
        GeneratedObjectMap data;
        break;
    case "DOCK":
        Docks data;
        break;
    case "BLIT":
        BakedLightning data;
        break;
    case "LUNS":
        uint16 loadUnitCount;
        break;
    case "LUHD":
        LoadUnitHeader data;
        break;
    case "LRES":
        LoadUnitResources data;
        break;
    case "LLYR":
        LoadUnitLayers data;
        break;
    case "STRP":
        STRP data;
        break;
    case "LHED":
        LayerHeader data;
        break;
    case "SDHR":
        ScriptDataHeader data;
        break;
    case "COMP":
        Component data;
        break;
    default:
        byte data[desc.size];
        break;
    }
    FSeek(start + desc.size);
} RoomChunk <
    name=(Str("%s chunk", desc.id)),
    comment=(SizeComment(desc.size))
>;

struct CGameAreaResource(uint64 size) {
    local uint64 start <hidden = true> = FTell();
    while (FTell() < start + size) {
        RoomChunk data;
    }
};

#endif // _CGAMEAREARESOURCE